<template>
<div class="wrapper">
  <div ref="container"></div>
  <div id="pano" ref="panoBox" style="display: inline"></div>
</div>
</template>

<script>
import Vuex from 'vuex'
var GSVPANO = require('gsvpano')
var _ = require('lodash')
var THREE = require('three')
// import GSVPANO from 'gsvpano'

export default {

  name: 'Scene',
  props: ['mapCenter'],
  components: {},
  data () {
    return {
      // canvas: null
      torus: null,
      lat: 51.50700703827454,
      lon: -0.12791916931155356,
      theta: null,
      phi: null,
      zoom: 1,
      camera: null,
      uniforms: null,
      mesh: null
    }
  },
  mounted(){

   var loader,
          container,
          marker
          // torus

  var container = this.$refs.container
  var preloader = document.getElementById( 'preloader' )
  // var bar = document.getElementById( 'bar' )
  // var options = document.getElementById( 'options' )
  // var title = document.getElementById( 'title' )
  var fov = 90,
      texture_placeholder,
      isUserInteracting = false,
      onMouseDownMouseX = 0, onMouseDownMouseY = 0,
      lon = 0, onMouseDownLon = 0,
      lat = 0, onMouseDownLat = 0,
      phi = 0, theta = 0
      lat = 15

  // this.init()
  // this.animate()

  var locations = [
    { lat: 51.50700703827454, lng: -0.12791916931155356 },
    { lat: 32.6144404, lng: -108.9852017 },
    { lat: 39.36382677360614, lng: 8.431220278759724 },
    { lat: 59.30571937680209, lng: 4.879402148657164 },
    { lat: 28.240385123352873, lng: -16.629988706884774 },
    { lat: 50.09072314148827, lng: 14.393133454556278 },
    { lat: 41.413416092316275, lng: 2.1531126527786455 },
    { lat: 35.69143938066447, lng: 139.695139627539 },
    { lat: 35.67120372775569, lng: 139.77167914398797 },
    { lat: 54.552083679428065, lng: -3.297380963134742 }
  ]
  
  var pos = locations[ Math.floor( Math.random() * locations.length ) ]
  
  var myLatlng = new google.maps.LatLng( pos.lat, pos.lng )
  
  var myOptions = {
    zoom: 14,
    center: myLatlng,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    streetViewControl: false
  }
  
  this.scene = new THREE.Scene()

  this.camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, 1, 1100 )
  this.camera.target = new THREE.Vector3( 0, 0, 0 )
  this.scene.add( this.camera )

  var shadowMaterial = new THREE.MeshBasicMaterial( { emissive: 0xffffff, color: 0xffffff, map: THREE.ImageUtils.loadTexture( require('assets/shadow.png') ), transparent: true } )
  var shadowGeo = new THREE.PlaneGeometry( 300, 300, 1, 1 )
  var plane = new THREE.Mesh( shadowGeo, shadowMaterial )
  plane.position.y = - 150
  plane.rotation.x = - 90 * Math.PI / 180
  this.scene.add( plane )

  this.mesh = new THREE.Mesh( new THREE.SphereGeometry( 500, 60, 40 ), new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( require('assets/placeholder.jpg') ) } ) )
  this.mesh.scale.x = -1
  this.scene.add( this.mesh )
  
  this.renderer = new THREE.WebGLRenderer( { antialias: true } )
  this.renderer.setSize( window.innerWidth, window.innerHeight )
  this.renderer.sortObjects = false

  this.$refs.container.appendChild( this.renderer.domElement )
  
  var shader = new THREE.ShaderMaterial( {
    uniforms: {
      texture: { type: 't', value: null },
      scaledTexture: { type: 't', value: null },
      rAmount: { type: 'f', value: 0.0 }
    },
    vertexShader: document.getElementById( 'vertexShader' ).textContent,
    fragmentShader: document.getElementById( 'fragmentShader' ).textContent
  } )
  
  this.uniforms = THREE.UniformsUtils.clone( shader.uniforms )
  var material = new THREE.ShaderMaterial( {
    fragmentShader: shader.fragmentShader,
    vertexShader: shader.vertexShader,
    uniforms: this.uniforms
  } )
  
  this.torus = new THREE.Mesh( new THREE.TorusKnotGeometry( 30, 10, 200, 50, 1, 3 ), material )
  this.scene.add( this.torus )
  
  // container.addEventListener( 'mousedown', onMouseDown, false )
  // container.addEventListener( 'mousemove', onMouseMove, false )
  // container.addEventListener( 'mouseup', onMouseUp, false )
  // container.addEventListener( 'mousewheel', onMouseWheel, false )
  // container.addEventListener( 'DOMMouseScroll', onMouseWheel, false)
  // window.addEventListener( 'resize', onWindowResized, false )
  
  // this.loadPanorama( myLatlng )
  
  this.render()
  },
  computed:{
  ...Vuex.mapGetters([]),

  },
  watch:{

    mapCenter: _.debounce(function(mapCenter){
      if(mapCenter){
         var self = this  
         console.log(mapCenter)
       var lat = mapCenter.lat
       var lng = mapCenter.lng
       var panoBox = this.$refs.panoBox
        
       // Create a loader.
       var loader = new GSVPANO.PanoLoader({
         zoom: self.zoom
       })

       
       // Implement the onPanoramaLoad handler
       loader.on('panorama.load', function(pano) {
        console.log('loading...')
         var canvas = self.$refs.panoBox
       })

       loader.on('panorama.data', function(pano) {
        console.log('getting data')
         var canvas = pano.canvas
         while (self.$refs.panoBox.firstChild) {
           self.$refs.panoBox.removeChild(self.$refs.panoBox.firstChild)
         }
         self.$refs.panoBox.appendChild(canvas)

         self.mesh.material.map = new THREE.Texture( canvas ) 
         self.mesh.material.map.needsUpdate = true
         
         // var canvas = document.createElement( 'canvas' )
         // var s = 2
         // canvas.width = source.width / s
         // canvas.height = source.height / s
         // var ctx = canvas.getContext( '2d' )
         // ctx.drawImage( source, 0, 0, source.width, source.height, 0, 0, canvas.width, canvas.height )
         
         self.uniforms[ 'texture' ].value = new THREE.Texture( canvas )
         self.uniforms[ 'texture' ].value.needsUpdate = true
         self.uniforms[ 'scaledTexture' ].value = new THREE.Texture( canvas )
         self.uniforms[ 'scaledTexture' ].value.needsUpdate = true


       })

       // Invoke the load method with a LatLng point.
       loader.load(new google.maps.LatLng(lat, lng))

       // Set error handle.
       loader.on('error', function(message) {
         console.log(message)
       })
      }

    }, 500),

  },
  methods:{
  ...Vuex.mapMutations([]), 
  ...Vuex.mapActions([]), 

  

  

  render: function() {
    
    
    this.torus.rotation.x += .01
    this.lon += .15
    
    this.lat = Math.max( - 85, Math.min( 85, this.lat ) )
    this.phi = ( 90 - this.lat ) * Math.PI / 180
    this.theta = this.lon * Math.PI / 180

    this.camera.position.x = 100 * Math.sin( this.phi ) * Math.cos( this.theta )
    this.camera.position.y = 100 * Math.cos( this.phi )
    this.camera.position.z = 100 * Math.sin( this.phi ) * Math.sin( this.theta )
    
    this.camera.lookAt( this.camera.target )
    
    this.renderer.render( this.scene, this.camera )

  },

  completeCallback: function(){
    console.log('completee!')
    var panoBox = this.$refs.panoBox
    while (panoBox.firstChild) {
         panoBox.removeChild(panoBox.firstChild)
       }
       panoBox.appendChild(this.canvas)
  },

  changeProgress: function(){
    console.log('changing...')
  }

  },
}
</script>

<style lang="css" scoped>

.wrapper{
  /*background-color: blue*/
}

</style>